//! Bindings for [`AIBinder`]
#![cfg(feature = "binder")]

// TODO: Move
#[derive(Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[doc(alias = "AParcel")]
pub struct Parcel {}

use std::{
    error,
    ffi::CStr,
    fmt,
    mem::MaybeUninit,
    os::{
        fd::{AsRawFd, BorrowedFd},
        raw::c_void,
    },
    ptr::NonNull,
};

use num_enum::{FromPrimitive, IntoPrimitive};

use crate::utils::abort_on_panic;

/// Media Status codes for [`binder_status_t`](https://developer.android.com/ndk/reference/group/media#group___media_1ga009a49041fe39f7bdc6d8b5cddbe760c)
#[repr(i32)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, FromPrimitive, IntoPrimitive)]
#[doc(alias = "binder_status_t")]
#[non_exhaustive]
pub enum BinderError {
    // #[doc(alias = "STATUS_OK")]
    // OK = ffi::STATUS_OK,
    #[doc(alias = "STATUS_UNKNOWN_ERROR")]
    UNKNOWN_ERROR = ffi::STATUS_UNKNOWN_ERROR,
    #[doc(alias = "STATUS_NO_MEMORY")]
    NO_MEMORY = ffi::STATUS_NO_MEMORY,
    #[doc(alias = "STATUS_INVALID_OPERATION")]
    INVALID_OPERATION = ffi::STATUS_INVALID_OPERATION,
    #[doc(alias = "STATUS_BAD_VALUE")]
    BAD_VALUE = ffi::STATUS_BAD_VALUE,
    #[doc(alias = "STATUS_BAD_TYPE")]
    BAD_TYPE = ffi::STATUS_BAD_TYPE,
    #[doc(alias = "STATUS_NAME_NOT_FOUND")]
    NAME_NOT_FOUND = ffi::STATUS_NAME_NOT_FOUND,
    #[doc(alias = "STATUS_PERMISSION_DENIED")]
    PERMISSION_DENIED = ffi::STATUS_PERMISSION_DENIED,
    #[doc(alias = "STATUS_NO_INIT")]
    NO_INIT = ffi::STATUS_NO_INIT,
    #[doc(alias = "STATUS_ALREADY_EXISTS")]
    ALREADY_EXISTS = ffi::STATUS_ALREADY_EXISTS,
    #[doc(alias = "STATUS_DEAD_OBJECT")]
    DEAD_OBJECT = ffi::STATUS_DEAD_OBJECT,
    #[doc(alias = "STATUS_FAILED_TRANSACTION")]
    FAILED_TRANSACTION = ffi::STATUS_FAILED_TRANSACTION,
    #[doc(alias = "STATUS_BAD_INDEX")]
    BAD_INDEX = ffi::STATUS_BAD_INDEX,
    #[doc(alias = "STATUS_NOT_ENOUGH_DATA")]
    NOT_ENOUGH_DATA = ffi::STATUS_NOT_ENOUGH_DATA,
    #[doc(alias = "STATUS_WOULD_BLOCK")]
    WOULD_BLOCK = ffi::STATUS_WOULD_BLOCK,
    #[doc(alias = "STATUS_TIMED_OUT")]
    TIMED_OUT = ffi::STATUS_TIMED_OUT,
    #[doc(alias = "STATUS_UNKNOWN_TRANSACTION")]
    UNKNOWN_TRANSACTION = ffi::STATUS_UNKNOWN_TRANSACTION,
    #[doc(alias = "STATUS_FDS_NOT_ALLOWED")]
    FDS_NOT_ALLOWED = ffi::STATUS_FDS_NOT_ALLOWED,
    #[doc(alias = "STATUS_UNEXPECTED_NULL")]
    UNEXPECTED_NULL = ffi::STATUS_UNEXPECTED_NULL,

    // Use the SUCCESS discriminant, as no-one will be able to call `as i32` and only has access to
    // the constants via `From` provided by `IntoPrimitive` which reads the contained value.
    // An autogenerated `<previous variant> + 1` discriminant is normally fine, except that the
    // previous variant is negative and `+ 1` would match the variant before that.
    #[doc(hidden)]
    #[num_enum(catch_all)]
    __Unknown(i32) = ffi::ANDROID_BITMAP_RESULT_SUCCESS,
}

impl fmt::Display for BinderError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

impl error::Error for BinderError {}

pub type Result<T, E = BinderError> = std::result::Result<T, E>;

impl BinderError {
    pub(crate) fn from_status(status: i32) -> Result<()> {
        match status {
            ffi::ANDROID_BITMAP_RESULT_SUCCESS => Ok(()),
            x => Err(Self::from(x)),
        }
    }
}

/**
 * This is called whenever a new AIBinder object is needed of a specific class.
 *
 * \param args these can be used to construct a new class. These are passed from AIBinder_new.
 * \return this is the userdata representing the class. It can be retrieved using
 * AIBinder_getUserData.
 */
#[doc(alias = "AIBinder_Class_onCreate")]
pub type IBinderClassOnCreate = Box<dyn FnMut(*mut c_void) -> *mut c_void>;

/**
 * This is called whenever an AIBinder object is no longer referenced and needs destroyed.
 *
 * Typically, this just deletes whatever the implementation is.
 *
 * \param userData this is the same object returned by AIBinder_Class_onCreate
 */
#[doc(alias = "AIBinder_Class_onDestroy")]
pub type IBinderClassOnDestroy = Box<dyn FnMut(*mut c_void)>;

/**
 * This is called whenever a transaction needs to be processed by a local implementation.
 *
 * This method will be called after the equivalent of
 * android.os.Parcel#enforceInterface is called. That is, the interface
 * descriptor associated with the AIBinder_Class descriptor will already be
 * checked.
 *
 * \param binder the object being transacted on.
 * \param code implementation-specific code representing which transaction should be taken.
 * \param in the implementation-specific input data to this transaction.
 * \param out the implementation-specific output data to this transaction.
 *
 * \return the implementation-specific output code. This may be forwarded from another service, the
 * result of a parcel read or write, or another error as is applicable to the specific
 * implementation. Usually, implementation-specific error codes are written to the output parcel,
 * and the transaction code is reserved for kernel errors or error codes that have been repeated
 * from subsequent transactions.
 */
#[doc(alias = "AIBinder_Class_onTransact")]
pub type IBinderClassOnTransact =
    Box<dyn FnMut(&IBinder, ffi::transaction_code_t, &Parcel, &mut Parcel) -> Result<()>>;

/**
 * Dump information about an AIBinder (usually for debugging).
 *
 * When no arguments are provided, a brief overview of the interview should be given.
 *
 * \param binder interface being dumped
 * \param fd file descriptor to be dumped to, should be flushed, ownership is not passed.
 * \param args array of null-terminated strings for dump (may be null if numArgs is 0)
 * \param numArgs number of args to be sent
 *
 * \return binder_status_t result of transaction (if remote, for instance)
 */
#[doc(alias = "AIBinder_onDump")]
pub type IBinderOnDump = Box<dyn FnMut(&IBinder, BorrowedFd<'_>, &mut [&CStr]) -> Result<()>>;

/// Represents a type of AIBinder object which can be sent out.
// TODO: This is some sort of singleton per interface_descriptor
#[derive(Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[doc(alias = "AIBinder_Class")]
pub struct IBinderClass {
    ptr: NonNull<ffi::AIBinder_Class>,
}

impl IBinderClass {
    /**
     * This creates a new instance of a class of binders which can be instantiated. This is called one
     * time during library initialization and cleaned up when the process exits or execs.
     *
     * None of these parameters can be null.
     *
     * \param interfaceDescriptor this is a unique identifier for the class. This is used internally for
     * validity checks on transactions. This should be utf-8.
     * \param onCreate see AIBinder_Class_onCreate.
     * \param onDestroy see AIBinder_Class_onDestroy.
     * \param onTransact see AIBinder_Class_onTransact.
     *
     * \return the class object representing these parameters or null on error.
     */
    #[doc(alias = "AIBinder_Class_define")]
    #[must_use]
    pub fn define(
        // TODO: Str lifetime?
        interface_descriptor: &CStr,
        onCreate: IBinderClassOnCreate,
        onDestroy: IBinderClassOnDestroy,
        onTransact: IBinderClassOnTransact,
    ) -> Option<Self> {
        todo!()
        // unsafe extern "C" fn onCreate() -> ffi::binder_status_t {
        //     abort_on_panic(|| {
        //         // TODO: This is the class itself?
        //         //       let callback = user_data as *mut
        //     })
        // }

        // unsafe extern "C" fn onDestroy() -> ffi::binder_status_t {
        //     abort_on_panic(|| {
        //         // TODO: This is the class itself?
        //         //       let callback = user_data as *mut
        //     })
        // }

        // unsafe extern "C" fn onTransact() -> ffi::binder_status_t {
        //     abort_on_panic(|| {
        //         // TODO: This is the class itself?
        //         //       let callback = user_data as *mut
        //     })
        // }

        // let class = unsafe {
        //     ffi::AIBinder_Class_define(
        //         interface_descriptor.as_ptr(),
        //         onCreate,
        //         onDestroy,
        //         onTransact,
        //     )
        // };
        // NonNull::new(class).map(|ptr| Self { ptr })
    }

    /**
     * This sets the implementation of the dump method for a class.
     *
     * If this isn't set, nothing will be dumped when dump is called (for instance with
     * android.os.Binder#dump). Must be called before any instance of the class is created.
     *
     * \param clazz class which should use this dump function
     * \param onDump function to call when an instance of this binder class is being dumped.
     */
    #[doc(alias = "AIBinder_Class_setOnDump")]
    pub fn set_on_dump(&mut self, onDump: IBinderOnDump) {
        // TODO: Store boxed fn?
        unsafe extern "C" fn onDump(
            binder: *mut ffi::AIBinder,
            fd: ::std::os::raw::c_int,
            args: *mut *const ::std::os::raw::c_char,
            numArgs: u32,
        ) -> ffi::binder_status_t {
            todo!()
            //     let binder = IBinder::from_ptr(binder);
            //     let fd = unsafe { BorrowedFd::borrow_raw(fd) };

            //     // TODO: Pull Box<onDump> from

            //     abort_on_panic(|| {
            //         let onDump = todo!();
            //         onDump(
            //             binder,
            //             fd,
            //             std::slice::from_raw_parts_mut(args, numArgs as usize),
            //         )
            //         // TODO: This is the class itself?
            //         //       let callback = user_data as *mut
            //     })
        }

        unsafe { ffi::AIBinder_Class_setOnDump(self.ptr.as_ptr(), Some(onDump)) }
    }

    /**
     * This tells users of this class not to use a transaction header. By default, libbinder_ndk users
     * read/write transaction headers implicitly (in the SDK, this must be manually written by
     * android.os.Parcel#writeInterfaceToken, and it is read/checked with
     * android.os.Parcel#enforceInterface). This method is provided in order to talk to legacy code
     * which does not write an interface token. When this is disabled, type safety is reduced, so you
     * must have a separate way of determining the binder you are talking to is the right type. Must
     * be called before any instance of the class is created.
     *
     * WARNING: this API interacts badly with linkernamespaces. For correct behavior, you must
     * use it on all instances of a class in the same process which share the same interface
     * descriptor. In general, it is recommended you do not use this API, because it is disabling
     * type safety.
     *
     * \param clazz class to disable interface header on.
     */
    #[cfg(feature = "api-level-33")]
    #[doc(alias = "AIBinder_Class_disableInterfaceTokenHeader")]
    pub fn disable_interface_token_header(&mut self) {
        unsafe { ffi::AIBinder_Class_disableInterfaceTokenHeader(self.ptr.as_ptr()) }
    }

    /**
     * Retrieve the class descriptor for the class.
     *
     * Available since API level 31.
     *
     * \param clazz the class to fetch the descriptor from
     *
     * \return the class descriptor string. This pointer will never be null; a
     * descriptor is required to define a class. The pointer is owned by the class
     * and will remain valid as long as the class does. For a local class, this will
     * be the same value (not necessarily pointer equal) as is passed into
     * [`AIBinderClass::define()`]. Format is utf-8.
     */
    #[cfg(feature = "api-level-31")]
    #[doc(alias = "AIBinder_Class_getDescriptor")]
    pub fn descriptor(&self) -> &str {
        let res = unsafe { ffi::AIBinder_Class_getDescriptor(self.ptr.as_ptr()) };
        unsafe { CStr::from_ptr(res) }
            .to_str()
            .expect("AIBinder_Class_getDescriptor should return UTF-8 per documentation")
    }
}

/// Represents a local or remote object which can be used for IPC or which can itself be sent.
#[derive(Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[doc(alias = "AIBinder")]
pub struct IBinder {
    ptr: NonNull<ffi::AIBinder>,
    //     class: Option<Pin<Box<IBinderClass>>>, // Contains the Box<dyn Fn>'s?
}

impl IBinder {
    /// Assumes ownership of `ptr`
    ///
    /// # Safety
    /// `ptr` must be a valid pointer to an Android [`ffi::AIBinder`].
    // TODO: Docs about not being created with a class but imported?
    pub unsafe fn from_ptr(ptr: NonNull<ffi::AIBinder>) -> Self {
        Self { ptr }
    }

    /// Acquires ownership of `ptr`
    ///
    /// # Safety
    /// `ptr` must be a valid pointer to an Android [`ffi::AIBinder`].
    pub unsafe fn clone_from_ptr(ptr: NonNull<ffi::AIBinder>) -> Self {
        ffi::AIBinder_incStrong(ptr.as_ptr());
        Self::from_ptr(ptr)
    }

    /**
     * Creates a new binder object of the appropriate class.
     *
     * Ownership of args is passed to this object. The lifecycle is implemented with AIBinder_incStrong
     * and AIBinder_decStrong. When the reference count reaches zero, onDestroy is called.
     *
     * When this is called, the refcount is implicitly 1. So, calling decStrong exactly one time is
     * required to delete this object.
     *
     * Once an AIBinder object is created using this API, re-creating that AIBinder for the same
     * instance of the same class will break pointer equality for that specific AIBinder object. For
     * instance, if someone erroneously created two AIBinder instances representing the same callback
     * object and passed one to a hypothetical addCallback function and then later another one to a
     * hypothetical removeCallback function, the remote process would have no way to determine that
     * these two objects are actually equal using the AIBinder pointer alone (which they should be able
     * to do). Also see the suggested memory ownership model suggested above.
     *
     * \param clazz the type of the object to be created.
     * \param args the args to pass to AIBinder_onCreate for that class.
     *
     * \return a binder object representing the newly instantiated object.
     */
    /// # Safety
    /// mut ptr deref?
    #[doc(alias = "AIBinder_new")]
    #[must_use]
    pub unsafe fn new(class: &IBinderClass, args: *mut c_void) -> Self {
        let binder = unsafe { ffi::AIBinder_new(class.ptr.as_ptr(), args) };

        Self {
            ptr: NonNull::new(binder).unwrap(),
        }
    }

    /**
     * If this is hosted in a process other than the current one.
     *
     * \param binder the binder being queried.
     *
     * \return true if the AIBinder represents an object in another process.
     */
    #[doc(alias = "AIBinder_isRemote")]
    pub fn is_remote(&self) -> bool {
        unsafe { ffi::AIBinder_isRemote(self.ptr.as_ptr()) }
    }

    /**
     * If this binder is known to be alive. This will not send a transaction to a remote process and
     * returns a result based on the last known information. That is, whenever a transaction is made,
     * this is automatically updated to reflect the current alive status of this binder. This will be
     * updated as the result of a transaction made using AIBinder_transact, but it will also be updated
     * based on the results of bookkeeping or other transactions made internally.
     *
     * \param binder the binder being queried.
     *
     * \return true if the binder is alive.
     */
    #[doc(alias = "AIBinder_isAlive")]
    pub fn is_alive(&self) -> bool {
        unsafe { ffi::AIBinder_isAlive(self.ptr.as_ptr()) }
    }

    /**
     * Built-in transaction for all binder objects. This sends a transaction that will immediately
     * return. Usually this is used to make sure that a binder is alive, as a placeholder call, or as a
     * consistency check.
     *
     * \param binder the binder being queried.
     *
     * \return STATUS_OK if the ping succeeds.
     */
    #[doc(alias = "AIBinder_ping")]
    pub fn ping(&self) -> Result<()> {
        let status = unsafe { ffi::AIBinder_ping(self.ptr.as_ptr()) };
        BinderError::from_status(status)
    }

    /**
     * Built-in transaction for all binder objects. This dumps information about a given binder.
     *
     * See also AIBinder_Class_setOnDump, AIBinder_onDump.
     *
     * \param binder the binder to dump information about
     * \param fd where information should be dumped to
     * \param args null-terminated arguments to pass (may be null if numArgs is 0)
     * \param numArgs number of args to send
     *
     * \return STATUS_OK if dump succeeds (or if there is nothing to dump)
     */
    #[doc(alias = "AIBinder_dump")]
    pub fn dump(&self, fd: BorrowedFd<'_>, args: &[&CStr]) -> Result<()> {
        let mut args = args.iter().map(|c| c.as_ptr()).collect::<Vec<_>>();
        let status = unsafe {
            ffi::AIBinder_dump(
                self.ptr.as_ptr(),
                fd.as_raw_fd(),
                // TODO: Why mut ptr?
                // args.as_mut_ptr(),
                std::ptr::null_mut(),
                args.len().try_into().expect("Overflow in usize -> i32"),
            )
        };
        dbg!(args);
        BinderError::from_status(status)
    }

    /**
     * Registers for notifications that the associated binder is dead. The same death recipient may be
     * associated with multiple different binders. If the binder is local, then no death recipient will
     * be given (since if the local process dies, then no recipient will exist to receive a
     * transaction). The cookie is passed to recipient in the case that this binder dies and can be
     * null. The exact cookie must also be used to unlink this transaction (see AIBinder_unlinkToDeath).
     * This function may return a binder transaction failure. The cookie can be used both for
     * identification and holding user data.
     *
     * If binder is local, this will return STATUS_INVALID_OPERATION.
     *
     * \param binder the binder object you want to receive death notifications from.
     * \param recipient the callback that will receive notifications when/if the binder dies.
     * \param cookie the value that will be passed to the death recipient on death.
     *
     * \return STATUS_OK on success.
     */
    #[doc(alias = "AIBinder_linkToDeath")]
    pub fn link_to_death(
        &self,
        recipient: IBinderDeathRecipient,
        cookie: *mut c_void,
    ) -> Result<()> {
        todo!()
        // let status =
        //     unsafe { ffi::AIBinder_linkToDeath(self.ptr.as_ptr(), Some(recipient), cookie) };
        // BinderError::from_status(status)
    }

    /**
     * Stops registration for the associated binder dying. Does not delete the recipient. This function
     * may return a binder transaction failure and in case the death recipient cannot be found, it
     * returns STATUS_NAME_NOT_FOUND.
     *
     * This only ever needs to be called when the AIBinder_DeathRecipient remains for use with other
     * AIBinder objects. If the death recipient is deleted, all binders will automatically be unlinked.
     * If the binder dies, it will automatically unlink. If the binder is deleted, it will be
     * automatically unlinked.
     *
     * Be aware that it is not safe to immediately deallocate the cookie when this call returns. If you
     * need to clean up the cookie, you should do so in the onUnlinked callback, which can be set using
     * AIBinder_DeathRecipient_setOnUnlinked.
     *
     * \param binder the binder object to remove a previously linked death recipient from.
     * \param recipient the callback to remove.
     * \param cookie the cookie used to link to death.
     *
     * \return STATUS_OK on success. STATUS_NAME_NOT_FOUND if the binder cannot be found to be unlinked.
     */
    #[doc(alias = "AIBinder_unlinkToDeath")]
    pub fn unlink_to_death(
        &self,
        recipient: &IBinderDeathRecipient,
        cookie: *mut c_void,
    ) -> Result<()> {
        todo!()
        // let status =
        //     unsafe { ffi::AIBinder_unlinkToDeath(self.ptr.as_ptr(), Some(recipient), cookie) };
        // BinderError::from_status(status)
    }

    /**
     * This returns the calling UID assuming that this thread is called from a thread that is processing
     * a binder transaction (for instance, in the implementation of AIBinder_Class_onTransact).
     *
     * This can be used with higher-level system services to determine the caller's identity and check
     * permissions.
     *
     * \return calling uid or the current process's UID if this thread isn't processing a transaction.
     */
    #[doc(alias = "AIBinder_getCallingUid")]
    pub fn calling_uid() -> ffi::uid_t {
        unsafe { ffi::AIBinder_getCallingUid() }
    }

    /**
     * This returns the calling PID assuming that this thread is called from a thread that is processing
     * a binder transaction (for instance, in the implementation of AIBinder_Class_onTransact).
     *
     * This can be used with higher-level system services to determine the caller's identity and check
     * permissions. However, when doing this, one should be aware of possible TOCTOU problems when the
     * calling process dies and is replaced with another process with elevated permissions and the same
     * PID.
     *
     * Warning: oneway transactions do not receive PID. Even if you expect
     * a transaction to be synchronous, a misbehaving client could send it
     * as a synchronous call and result in a 0 PID here. Additionally, if
     * there is a race and the calling process dies, the PID may still be
     * 0 for a synchronous call.
     *
     * \return calling pid or the current process's PID if this thread isn't processing a transaction.
     * If the transaction being processed is a oneway transaction, then this method will return 0.
     */
    #[doc(alias = "AIBinder_getCallingPid")]
    pub fn calling_pid() -> ffi::pid_t {
        unsafe { ffi::AIBinder_getCallingPid() }
    }

    /**
     * Determine whether the current thread is currently executing an incoming transaction.
     *
     * \return true if the current thread is currently executing an incoming transaction, and false
     * otherwise.
     */
    #[cfg(feature = "api-level-33")]
    #[doc(alias = "AIBinder_isHandlingTransaction")]
    pub fn is_handling_transaction() -> bool {
        unsafe { ffi::AIBinder_isHandlingTransaction() }
    }

    /**
     * For debugging only!
     *
     * \param binder the binder object to retrieve the refcount of.
     *
     * \return the number of strong-refs on this binder in this process. If binder is null, this will be
     * -1.
     */
    #[doc(alias = "AIBinder_debugGetRefCount")]
    pub fn debug_get_ref_count(&self) -> i32 {
        unsafe { ffi::AIBinder_debugGetRefCount(self.ptr.as_ptr()) }
    }

    /**
     * This sets the class of an AIBinder object. This checks to make sure the remote object is of
     * the expected class. A class must be set in order to use transactions on an AIBinder object.
     * However, if an object is just intended to be passed through to another process or used as a
     * handle this need not be called.
     *
     * This returns true if the class association succeeds. If it fails, no change is made to the
     * binder object.
     *
     * Warning: this may fail if the binder is dead.
     *
     * \param binder the object to attach the class to.
     * \param clazz the clazz to attach to binder.
     *
     * \return true if the binder has the class clazz and if the association was successful.
     */
    #[doc(alias = "AIBinder_associateClass")]
    pub fn associate_class(&self, class: &IBinderClass) -> bool {
        unsafe { ffi::AIBinder_associateClass(self.ptr.as_ptr(), class.ptr.as_ptr()) }
    }

    /**
     * Returns the class that this binder was constructed with or associated with.
     *
     * \param binder the object that is being queried.
     *
     * \return the class that this binder is associated with. If this binder wasn't created with
     * AIBinder_new, and AIBinder_associateClass hasn't been called, then this will return null.
     */
    #[doc(alias = "AIBinder_getClass")]
    // TODO: Lifetime?
    pub fn class(&self) -> Option<&IBinderClass> {
        let class = unsafe { ffi::AIBinder_getClass(self.ptr.as_ptr()) };

        todo!()
        // NonNull::new(class).map(IBinderClass::from_ptr)
    }

    /**
     * Value returned by onCreate for a local binder. For stateless classes (if onCreate returns
     * null), this also returns null. For a remote binder, this will always return null.
     *
     * \param binder the object that is being queried.
     *
     * \return the userdata returned from AIBinder_onCreate when this object was created. This may be
     * null for stateless objects. For remote objects, this is always null.
     */
    // TODO: Use internally for Box/callback storage struct, with a T for user data?
    #[doc(alias = "AIBinder_getUserData")]
    pub fn user_data(&self) -> *mut c_void {
        unsafe { ffi::AIBinder_getUserData(self.ptr.as_ptr()) }
    }

    /**
     * A transaction is a series of calls to these functions which looks this
     * - call AIBinder_prepareTransaction
     * - fill out the in parcel with parameters (lifetime of the 'in' variable)
     * - call AIBinder_transact
     * - read results from the out parcel (lifetime of the 'out' variable)
     */

    /**
     * Creates a parcel to start filling out for a transaction. This will add a header to the
     * transaction that corresponds to android.os.Parcel#writeInterfaceToken. This may add debugging
     * or other information to the transaction for platform use or to enable other features to work. The
     * contents of this header is a platform implementation detail, and it is required to use
     * libbinder_ndk. This parcel is to be sent via AIBinder_transact and it represents the input data
     * to the transaction. It is recommended to check if the object is local and call directly into its
     * user data before calling this as the parceling and unparceling cost can be avoided. This AIBinder
     * must be either built with a class or associated with a class before using this API.
     *
     * This does not affect the ownership of binder. When this function succeeds, the in parcel's
     * ownership is passed to the caller. At this point, the parcel can be filled out and passed to
     * AIBinder_transact. Alternatively, if there is an error while filling out the parcel, it can be
     * deleted with AParcel_delete.
     *
     * \param binder the binder object to start a transaction on.
     * \param in out parameter for input data to the transaction.
     *
     * \return STATUS_OK on success. This will return STATUS_INVALID_OPERATION if the binder has not yet
     * been associated with a class (see AIBinder_new and AIBinder_associateClass).
     */
    #[doc(alias = "AIBinder_prepareTransaction")]
    pub fn prepare_transaction(&self) -> Result<Parcel> {
        todo!()
        // let status =
        //     unsafe { ffi::AIBinder_prepareTransaction(self.ptr.as_ptr(), in_.ptr.as_ptr()) };
        // BinderError::from_status(status)
    }

    /**
     * Transact using a parcel created from AIBinder_prepareTransaction. This actually communicates with
     * the object representing this binder object. This also passes out a parcel to be used for the
     * return transaction. This takes ownership of the in parcel and automatically deletes it after it
     * is sent to the remote process. The output parcel is the result of the transaction. If the
     * transaction has FLAG_ONEWAY, the out parcel will be empty. Otherwise, this will block until the
     * remote process has processed the transaction, and the out parcel will contain the output data
     * from transaction.
     *
     * This does not affect the ownership of binder. The out parcel's ownership is passed to the caller
     * and must be released with AParcel_delete when finished reading.
     *
     * \param binder the binder object to transact on.
     * \param code the implementation-specific code representing which transaction should be taken.
     * \param in the implementation-specific input data to this transaction.
     * \param out the implementation-specific output data to this transaction.
     * \param flags possible flags to alter the way in which the transaction is conducted or 0.
     *
     * \return the result from the kernel or from the remote process. Usually, implementation-specific
     * error codes are written to the output parcel, and the transaction code is reserved for kernel
     * errors or error codes that have been repeated from subsequent transactions.
     */
    #[doc(alias = "AIBinder_transact")]
    pub fn transact(
        &self,
        code: ffi::transaction_code_t,
        in_: Parcel,
        flags: ffi::binder_flags_t,
    ) -> Result<Parcel> {
        todo!()
        // let status = unsafe {
        //     ffi::AIBinder_transact(
        //         self.ptr.as_ptr(),
        //         code,
        //         in_.ptr.as_ptr(),
        //         out.ptr.as_ptr(),
        //         flags,
        //     )
        // };
        // BinderError::from_status(status)
    }

    /**
     * Gets the extension registered with AIBinder_setExtension.
     *
     * See AIBinder_setExtension.
     *
     * \param binder the object to get the extension of.
     * \param outExt the returned extension object. Will be null if there is no extension set or
     * non-null with one strong ref count.
     *
     * \return error of getting the interface (may be a transaction error if this is
     * remote binder). STATUS_UNEXPECTED_NULL if binder is null.
     */
    #[cfg(feature = "api-level-30")]
    #[doc(alias = "AIBinder_getExtension")]
    // TODO: Does "with one strong ref count" mean that we're returning an owned thing?!?
    pub fn extension(&self) -> Result<Option<IBinder>> {
        let mut out = MaybeUninit::uninit();
        let status = unsafe { ffi::AIBinder_getExtension(self.ptr.as_ptr(), out.as_mut_ptr()) };

        todo!()
        // BinderError::from_status(status)
        //     .map(|| out.assume_init())
        //     .map(Self::assume_from_ptr)
    }

    /**
     * Gets the extension of a binder interface. This allows a downstream developer to add
     * an extension to an interface without modifying its interface file. This should be
     * called immediately when the object is created before it is passed to another thread.
     * No thread safety is required.
     *
     * For instance, imagine if we have this interface:
     *     interface IFoo { void doFoo(); }
     *
     * A). Historical option that has proven to be BAD! Only the original
     *     author of an interface should change an interface. If someone
     *     downstream wants additional functionality, they should not ever
     *     change the interface or use this method.
     *
     *    BAD TO DO:  interface IFoo {                       BAD TO DO
     *    BAD TO DO:      void doFoo();                      BAD TO DO
     *    BAD TO DO: +    void doBar(); // adding a method   BAD TO DO
     *    BAD TO DO:  }                                      BAD TO DO
     *
     * B). Option that this method enables.
     *     Leave the original interface unchanged (do not change IFoo!).
     *     Instead, create a new interface in a downstream package:
     *
     *         package com.<name>; // new functionality in a new package
     *         interface IBar { void doBar(); }
     *
     *     When registering the interface, add:
     *         std::shared_ptr<MyFoo> foo = new MyFoo; // class in AOSP codebase
     *         std::shared_ptr<MyBar> bar = new MyBar; // custom extension class
     *         ... = AIBinder_setExtension(foo->asBinder().get(), bar->asBinder().get());
     *         // handle error
     *
     *     Then, clients of IFoo can get this extension:
     *         SpAIBinder binder = ...;
     *         std::shared_ptr<IFoo> foo = IFoo::fromBinder(binder); // handle if null
     *         SpAIBinder barBinder;
     *         ... = AIBinder_getExtension(barBinder.get());
     *         // handle error
     *         std::shared_ptr<IBar> bar = IBar::fromBinder(barBinder);
     *         // type is checked with AIBinder_associateClass
     *         // if bar is null, then there is no extension or a different
     *         // type of extension
     *
     * \param binder the object to get the extension on. Must be local.
     * \param ext the extension to set (binder will hold a strong reference to this)
     *
     * \return OK on success, STATUS_INVALID_OPERATION if binder is not local, STATUS_UNEXPECTED_NULL
     * if either binder is null.
     */
    #[cfg(feature = "api-level-30")]
    #[doc(alias = "AIBinder_setExtension")]
    // TODO: Lifetime transition?
    pub fn set_extension(&self, ext: &IBinder) -> Result<()> {
        let status = unsafe { ffi::AIBinder_setExtension(self.ptr.as_ptr(), ext.ptr.as_ptr()) };
        BinderError::from_status(status)
    }

    /**
     * Whether AIBinder is less than another.
     *
     * This provides a per-process-unique total ordering of binders where a null
     * AIBinder* object is considered to be before all other binder objects.
     * For instance, two binders refer to the same object in a local or remote
     * process when both AIBinder_lt(a, b) and AIBinder(b, a) are false. This API
     * might be used to insert and lookup binders in binary search trees.
     *
     * AIBinder* pointers themselves actually also create a per-process-unique total
     * ordering. However, this ordering is inconsistent with AIBinder_Weak_lt for
     * remote binders. So, in general, this function should be preferred.
     *
     * \param lhs comparison object
     * \param rhs comparison object
     *
     * \return whether "lhs < rhs" is true
     */
    #[cfg(feature = "api-level-31")]
    #[doc(alias = "AIBinder_lt")]
    pub fn lt(lhs: &IBinder, rhs: &IBinder) -> bool {
        unsafe { ffi::AIBinder_lt(lhs.ptr.as_ptr(), rhs.ptr.as_ptr()) }
    }
}

impl Clone for IBinder {
    /**
     * This can only be called if a strong reference to this object already exists in process.
     *
     * \param binder the binder object to add a refcount to.
     */
    #[doc(alias = "AIBinder_incStrong")]
    fn clone(&self) -> Self {
        unsafe { ffi::AIBinder_incStrong(self.ptr.as_ptr()) };
        Self { ptr: self.ptr }
    }
}

impl Drop for IBinder {
    /**
     * This will delete the object and call onDestroy once the refcount reaches zero.
     *
     * \param binder the binder object to remove a refcount from.
     */
    #[doc(alias = "AIBinder_decStrong")]
    fn drop(&mut self) {
        unsafe { ffi::AIBinder_decStrong(self.ptr.as_ptr()) }
    }
}

// impl IBinderWeak {

// /**
//  * This does not take any ownership of the input binder, but it can be used to retrieve it if
//  * something else in some process still holds a reference to it.
//  *
//  * \param binder object to create a weak pointer to.
//  *
//  * \return object representing a weak pointer to binder (or null if binder is null).
//  */
// #[must_use] AIBinder_Weak* AIBinder_Weak_new(AIBinder* binder)
//         ;

// /**
//  * Deletes the weak reference. This will have no impact on the lifetime of the binder.
//  *
//  * \param weakBinder object created with AIBinder_Weak_new.
//  */
// void AIBinder_Weak_delete(AIBinder_Weak* weakBinder) ;

// /**
//  * If promotion succeeds, result will have one strong refcount added to it. Otherwise, this returns
//  * null.
//  *
//  * \param weakBinder weak pointer to attempt retrieving the original object from.
//  *
//  * \return an AIBinder object with one refcount given to the caller or null.
//  */
// #[must_use] AIBinder* AIBinder_Weak_promote(AIBinder_Weak* weakBinder)
//         ;

// /**
//  * Clone an AIBinder_Weak. Useful because even if a weak binder promotes to a
//  * null value, after further binder transactions, it may no longer promote to a
//  * null value.
//  *
//  * Available since API level 31.
//  *
//  * \param weak Object to clone
//  *
//  * \return clone of the input parameter. This must be deleted with
//  * AIBinder_Weak_delete. Null if weak input parameter is also null.
//  */
// AIBinder_Weak* AIBinder_Weak_clone(const AIBinder_Weak* weak) __INTRODUCED_IN(31);

// /**
//  * Whether AIBinder_Weak is less than another.
//  *
//  * This provides a per-process-unique total ordering of binders which is exactly
//  * the same as AIBinder_lt. Similarly, a null AIBinder_Weak* is considered to be
//  * ordered before all other weak references.
//  *
//  * This function correctly distinguishes binders even if one is deallocated. So,
//  * for instance, an AIBinder_Weak* entry representing a deleted binder will
//  * never compare as equal to an AIBinder_Weak* entry which represents a
//  * different allocation of a binder, even if the two binders were originally
//  * allocated at the same address. That is:
//  *
//  *     AIBinder* a = ...; // imagine this has address 0x8
//  *     AIBinder_Weak* bWeak = AIBinder_Weak_new(a);
//  *     AIBinder_decStrong(a); // a may be deleted, if this is the last reference
//  *     AIBinder* b = ...; // imagine this has address 0x8 (same address as b)
//  *     AIBinder_Weak* bWeak = AIBinder_Weak_new(b);
//  *
//  * Then when a/b are compared with other binders, their order will be preserved,
//  * and it will either be the case that AIBinder_Weak_lt(aWeak, bWeak) OR
//  * AIBinder_Weak_lt(bWeak, aWeak), but not both.
//  *
//  * Unlike AIBinder*, the AIBinder_Weak* addresses themselves have nothing to do
//  * with the underlying binder.
//  *
//  * Available since API level 31.
//  *
//  * \param lhs comparison object
//  * \param rhs comparison object
//  *
//  * \return whether "lhs < rhs" is true
//  */
// bool AIBinder_Weak_lt(const AIBinder_Weak* lhs, const AIBinder_Weak* rhs) __INTRODUCED_IN(31);

// }

// /**
//  * This function is executed on death receipt. See AIBinder_linkToDeath/AIBinder_unlinkToDeath.
//  *
//  * \param cookie the cookie passed to AIBinder_linkToDeath.
//  */
// #[doc(alias = "AIBinder_DeathRecipient_onBinderDied")]
// type AIBinder_DeathRecipient_onBinderDied = FnMut(void* cookie) ;

// /**
//  * This function is intended for cleaning up the data in the provided cookie, and it is executed
//  * when the DeathRecipient is unlinked. When the DeathRecipient is unlinked due to a death receipt,
//  * this method is called after the call to onBinderDied.
//  *
//  * This method is called once for each binder that is unlinked. Hence, if the same cookie is passed
//  * to multiple binders, then the caller is responsible for reference counting the cookie.
//  *
//  * See also AIBinder_linkToDeath/AIBinder_unlinkToDeath.
//  *
//  * WARNING: Make sure the lifetime of this cookie is long enough. If it is dynamically
//  * allocated, it should be deleted with AIBinder_DeathRecipient_setOnUnlinked.
//  *
//  * Available since API level 33.
//  *
//  * \param cookie the cookie passed to AIBinder_linkToDeath.
//  */
// #[doc(alias = "AIBinder_DeathRecipient_onBinderUnlinked")]
// type AIBinder_DeathRecipient_onBinderUnlinked = FnMut(void* cookie) __INTRODUCED_IN(33);

/// Represents a handle on a death notification. See AIBinder_linkToDeath/AIBinder_unlinkToDeath.
#[derive(Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[doc(alias = "AIBinder_DeathRecipient")]
pub struct IBinderDeathRecipient {
    ptr: NonNull<ffi::AIBinder_DeathRecipient>,
}

// impl IBinderDeathRecipient {

// /**
//  * Creates a new binder death recipient. This can be attached to multiple different binder objects.
//  *
//  * WARNING: Make sure the lifetime of this cookie is long enough. If it is dynamically
//  * allocated, it should be deleted with AIBinder_DeathRecipient_setOnUnlinked.
//  *
//  * \param onBinderDied the callback to call when this death recipient is invoked.
//  *
//  * \return the newly constructed object (or null if onBinderDied is null).
//  */
// #[must_use] AIBinder_DeathRecipient* AIBinder_DeathRecipient_new(
//         AIBinder_DeathRecipient_onBinderDied onBinderDied) ;

// /**
//  * Set the callback to be called when this DeathRecipient is unlinked from a binder. The callback is
//  * called in the following situations:
//  *
//  *  1. If the binder died, shortly after the call to onBinderDied.
//  *  2. If the binder is explicitly unlinked with AIBinder_unlinkToDeath or
//  *     AIBinder_DeathRecipient_delete, after any pending onBinderDied calls
//  *     finish.
//  *  3. During or shortly after the AIBinder_linkToDeath call if it returns an error.
//  *
//  * It is guaranteed that the callback is called exactly once for each call to linkToDeath unless the
//  * process is aborted before the binder is unlinked.
//  *
//  * Be aware that when the binder is explicitly unlinked, it is not guaranteed that onUnlinked has
//  * been called before the call to AIBinder_unlinkToDeath or AIBinder_DeathRecipient_delete returns.
//  * For example, if the binder dies concurrently with a call to AIBinder_unlinkToDeath, the binder is
//  * not unlinked until after the death notification is delivered, even if AIBinder_unlinkToDeath
//  * returns before that happens.
//  *
//  * This method should be called before linking the DeathRecipient to a binder because the function
//  * pointer is cached. If you change it after linking to a binder, it is unspecified whether the old
//  * binder will call the old or new onUnlinked callback.
//  *
//  * The onUnlinked argument may be null. In this case, no notification is given when the binder is
//  * unlinked.
//  *
//  * Available since API level 33.
//  *
//  * \param recipient the DeathRecipient to set the onUnlinked callback for.
//  * \param onUnlinked the callback to call when a binder is unlinked from recipient.
//  */
// void AIBinder_DeathRecipient_setOnUnlinked(AIBinder_DeathRecipient* recipient,
//                                            AIBinder_DeathRecipient_onBinderUnlinked onUnlinked)
//         __INTRODUCED_IN(33);

// /**
//  * Deletes a binder death recipient. It is not necessary to call AIBinder_unlinkToDeath before
//  * calling this as these will all be automatically unlinked.
//  *
//  * Be aware that it is not safe to immediately deallocate the cookie when this call returns. If you
//  * need to clean up the cookie, you should do so in the onUnlinked callback, which can be set using
//  * AIBinder_DeathRecipient_setOnUnlinked.
//  *
//  * \param recipient the binder to delete (previously created with AIBinder_DeathRecipient_new).
//  */
// void AIBinder_DeathRecipient_delete(AIBinder_DeathRecipient* recipient) ;
// }
